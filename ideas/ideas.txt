Concepts for single player Interactive Fiction mode:
----------------------------------------------------
Self-modifying rooms/exits to create a more dynamic game world.
do this with state transitions through conditional exits? Or actually replace exits/locations with new ones?
HTTP server mode with HTML+Javascript frontend.
Tkinter gui driver (textarea for output, editbox for commands) -> inherit from regular driver
Pictures for locations (viewable in gui driver/html version only)


Concepts for multiplayer MUD mode (and not really for single player I.F.):
--------------------------------------------------------------------------
Check for and disable IF-specific stuff. (make the @disable_in_IF decorator more general into @disable_in_gamemode("..."))
Let players define aliases for certain commands (including args).
Write stuff to a logfile for the server admins.
Mailbox system: can mail messages, money and items to other players. Only when mailbox in environment?
Bulletin boards.
Pets: tame/befriend/abandon (charisma/luck)
Combat: backstab (stealth/charisma/luck/agility?  vs luck/wisdom/agility)
Follow other creatures: follow.  If you have a follower and want to try to stop him: evade
Party: team up with other players and share quest and combat experience
Skills: stealth, lockpicking, ...
Vendors and shops: stock, sell stuff, buy stuff, haggle?
World zones: (optional) timed zone resets to reset to starting configuration. Or global server reset?

Do something with the circlemud xml data:
  http://inventwithpython.com/blog/2012/03/19/circlemud-data-in-xml-format-for-your-text-adventure-game/


General ideas/TODO:
-------------------
BUG:  say X to <exit> / wait for <exit> ==> crash

change **ctx to a proper object+attributes for all cmds

Improve the game clock:
 - option to not advance automatically at all
 - option to only advance when changing locations?
 - explicitly advance time when player waits

File system abstraction: resourceloader should also be able to *save* stuff (savegames).
Player I/O abstraction: add an input/output layer.
Player output should not be printed directly to stdout by the driver.
Player input should not be read directly from stdin.

Instead of using colors directly in the output, use basic html-ish or bbcode markup (dim/normal/bright, underline, negative (reversevideo) and the 8 ansi colors)
The I/O abstraction should convert this to the appropriate output (colorama/ true html/ whatever).

Fix the textformatting to deal with colorama effects taking up character width.
TextOutput.render should probably be removed as the I/O abstraction will take care of that.
(rename Textoutput to Textbuffer?)

Use mdx_smartypants to automatically add some nice typography (quotes etc) when using HTML-output.

Better naming of exits/doors; they need to know their own name (direction). It can now be None...
Exits should be defined more clearly, instead of scattered through the code on a per-room basis,
there should be a single table where all exits are defined. But how to link to code if it is not a normal plain exit?

Finite-state-machine to support multi-phase actions (such as a short dialog with an npc)?
(note: less suited for MUDs because people might interfere)

Console output: dynamically highlight names/aliases/exits/items? (Problem: textwrap also counts the ansi escape sequences)

input should be case insensitive (everything except stuff in quotes - the message)
  commands, adverbs, names - all should be lowercased and compared by lowercase.

Load story from a zipfile. So the resource loader should be able to load stuff from zipfile too!

Obfuscated resource files (to avoid easy spoilers by simply reading the game files)?

Parser (bug): say "I don't get it" -> it thinks the message stops at the single quote in "don't".
Parser: remember previous objects/creatures so you can refer to them as 'it/him/her/them'.
Parser: allow simple question/answer dialog. 'no/yes' verbs? Use answer/say/tell?  Or use state machine (overkill for a simple question state)?

Invisible objects (only visible to a wizard.) Perhaps easiest by setting title and description to None?
(name can't be None because the object needs a way to identify it).

allow_move/item.move: pass the verb as well so it can output specific messages (you can't move/take/drop it).
should Exit inherit from MudObject? (it contains a fair amount of similar methods now)
use lang.a more?
less use of isinstance?
prototypes to extend items/npc instead of inheritance? or use a DSL altogether to define the basic world stuff?
ASCII-art parser to easily define mazes/dungeons

test when player name == npc name (movement, examine, talk, soul emotes, destroy player)
test with multiple items of same name in room, in inventory, in bag
Bug: when item X is in inventory, can't take another X from the room ("there's no X here")

Change living location logic so that livings can sit inside a container item too.
Then:  go-in (wizard): step into something, go-out (wizard): step out of current location
+ take <living> actually working! (take ant, trap rabbit in cage, ...)


DAMAGE TYPES (MUD)
------------------
blunt, slash, pierce, water, shock, cold, heat, gas, acid, magic, poison,
disease, trauma, psionic, suffocation, deathray, emotional, sonic,
E.M.P., karma, drama, pressure, underpressure, inertia

Light/Dark
----------
light level in rooms: dark/light? or three states?  (0=pitch black, 0.5=dark/dusk, 1=normal daylight)
darkness in locations -> can't see location/exits/items/players (unless they're fluorescent, or unless you explicitly examine <direction>?)
if there's a lightsource in the room (or someone has a light source in their inventory), the room is lit.
 Conditional location description (light/dark etc)
